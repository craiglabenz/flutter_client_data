// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'results.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$WriteSuccess<T> {
  T get item => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $WriteSuccessCopyWith<T, WriteSuccess<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $WriteSuccessCopyWith<T, $Res> {
  factory $WriteSuccessCopyWith(
          WriteSuccess<T> value, $Res Function(WriteSuccess<T>) then) =
      _$WriteSuccessCopyWithImpl<T, $Res, WriteSuccess<T>>;
  @useResult
  $Res call({T item});
}

/// @nodoc
class _$WriteSuccessCopyWithImpl<T, $Res, $Val extends WriteSuccess<T>>
    implements $WriteSuccessCopyWith<T, $Res> {
  _$WriteSuccessCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? item = freezed,
  }) {
    return _then(_value.copyWith(
      item: freezed == item
          ? _value.item
          : item // ignore: cast_nullable_to_non_nullable
              as T,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$WriteSuccessImplCopyWith<T, $Res>
    implements $WriteSuccessCopyWith<T, $Res> {
  factory _$$WriteSuccessImplCopyWith(_$WriteSuccessImpl<T> value,
          $Res Function(_$WriteSuccessImpl<T>) then) =
      __$$WriteSuccessImplCopyWithImpl<T, $Res>;
  @override
  @useResult
  $Res call({T item});
}

/// @nodoc
class __$$WriteSuccessImplCopyWithImpl<T, $Res>
    extends _$WriteSuccessCopyWithImpl<T, $Res, _$WriteSuccessImpl<T>>
    implements _$$WriteSuccessImplCopyWith<T, $Res> {
  __$$WriteSuccessImplCopyWithImpl(
      _$WriteSuccessImpl<T> _value, $Res Function(_$WriteSuccessImpl<T>) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? item = freezed,
  }) {
    return _then(_$WriteSuccessImpl<T>(
      freezed == item
          ? _value.item
          : item // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$WriteSuccessImpl<T> implements _WriteSuccess<T> {
  const _$WriteSuccessImpl(this.item);

  @override
  final T item;

  @override
  String toString() {
    return 'WriteSuccess<$T>(item: $item)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$WriteSuccessImpl<T> &&
            const DeepCollectionEquality().equals(other.item, item));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(item));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$WriteSuccessImplCopyWith<T, _$WriteSuccessImpl<T>> get copyWith =>
      __$$WriteSuccessImplCopyWithImpl<T, _$WriteSuccessImpl<T>>(
          this, _$identity);
}

abstract class _WriteSuccess<T> implements WriteSuccess<T> {
  const factory _WriteSuccess(final T item) = _$WriteSuccessImpl<T>;

  @override
  T get item;
  @override
  @JsonKey(ignore: true)
  _$$WriteSuccessImplCopyWith<T, _$WriteSuccessImpl<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$BulkWriteSuccess<T> {
  List<T> get items => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $BulkWriteSuccessCopyWith<T, BulkWriteSuccess<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BulkWriteSuccessCopyWith<T, $Res> {
  factory $BulkWriteSuccessCopyWith(
          BulkWriteSuccess<T> value, $Res Function(BulkWriteSuccess<T>) then) =
      _$BulkWriteSuccessCopyWithImpl<T, $Res, BulkWriteSuccess<T>>;
  @useResult
  $Res call({List<T> items});
}

/// @nodoc
class _$BulkWriteSuccessCopyWithImpl<T, $Res, $Val extends BulkWriteSuccess<T>>
    implements $BulkWriteSuccessCopyWith<T, $Res> {
  _$BulkWriteSuccessCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? items = null,
  }) {
    return _then(_value.copyWith(
      items: null == items
          ? _value.items
          : items // ignore: cast_nullable_to_non_nullable
              as List<T>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$BulkWriteSuccessImplCopyWith<T, $Res>
    implements $BulkWriteSuccessCopyWith<T, $Res> {
  factory _$$BulkWriteSuccessImplCopyWith(_$BulkWriteSuccessImpl<T> value,
          $Res Function(_$BulkWriteSuccessImpl<T>) then) =
      __$$BulkWriteSuccessImplCopyWithImpl<T, $Res>;
  @override
  @useResult
  $Res call({List<T> items});
}

/// @nodoc
class __$$BulkWriteSuccessImplCopyWithImpl<T, $Res>
    extends _$BulkWriteSuccessCopyWithImpl<T, $Res, _$BulkWriteSuccessImpl<T>>
    implements _$$BulkWriteSuccessImplCopyWith<T, $Res> {
  __$$BulkWriteSuccessImplCopyWithImpl(_$BulkWriteSuccessImpl<T> _value,
      $Res Function(_$BulkWriteSuccessImpl<T>) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? items = null,
  }) {
    return _then(_$BulkWriteSuccessImpl<T>(
      null == items
          ? _value._items
          : items // ignore: cast_nullable_to_non_nullable
              as List<T>,
    ));
  }
}

/// @nodoc

class _$BulkWriteSuccessImpl<T> implements _BulkWriteSuccess<T> {
  const _$BulkWriteSuccessImpl(final List<T> items) : _items = items;

  final List<T> _items;
  @override
  List<T> get items {
    if (_items is EqualUnmodifiableListView) return _items;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_items);
  }

  @override
  String toString() {
    return 'BulkWriteSuccess<$T>(items: $items)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BulkWriteSuccessImpl<T> &&
            const DeepCollectionEquality().equals(other._items, _items));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_items));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$BulkWriteSuccessImplCopyWith<T, _$BulkWriteSuccessImpl<T>> get copyWith =>
      __$$BulkWriteSuccessImplCopyWithImpl<T, _$BulkWriteSuccessImpl<T>>(
          this, _$identity);
}

abstract class _BulkWriteSuccess<T> implements BulkWriteSuccess<T> {
  const factory _BulkWriteSuccess(final List<T> items) =
      _$BulkWriteSuccessImpl<T>;

  @override
  List<T> get items;
  @override
  @JsonKey(ignore: true)
  _$$BulkWriteSuccessImplCopyWith<T, _$BulkWriteSuccessImpl<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$WriteFailure<T> {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() conflict,
    required TResult Function(String message) error,
    required TResult Function(String id) notFound,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? conflict,
    TResult? Function(String message)? error,
    TResult? Function(String id)? notFound,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? conflict,
    TResult Function(String message)? error,
    TResult Function(String id)? notFound,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_WriteFailureConfict<T> value) conflict,
    required TResult Function(_WriteFailureError<T> value) error,
    required TResult Function(_WriteFailureItemNotFound<T> value) notFound,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_WriteFailureConfict<T> value)? conflict,
    TResult? Function(_WriteFailureError<T> value)? error,
    TResult? Function(_WriteFailureItemNotFound<T> value)? notFound,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_WriteFailureConfict<T> value)? conflict,
    TResult Function(_WriteFailureError<T> value)? error,
    TResult Function(_WriteFailureItemNotFound<T> value)? notFound,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $WriteFailureCopyWith<T, $Res> {
  factory $WriteFailureCopyWith(
          WriteFailure<T> value, $Res Function(WriteFailure<T>) then) =
      _$WriteFailureCopyWithImpl<T, $Res, WriteFailure<T>>;
}

/// @nodoc
class _$WriteFailureCopyWithImpl<T, $Res, $Val extends WriteFailure<T>>
    implements $WriteFailureCopyWith<T, $Res> {
  _$WriteFailureCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$WriteFailureConfictImplCopyWith<T, $Res> {
  factory _$$WriteFailureConfictImplCopyWith(_$WriteFailureConfictImpl<T> value,
          $Res Function(_$WriteFailureConfictImpl<T>) then) =
      __$$WriteFailureConfictImplCopyWithImpl<T, $Res>;
}

/// @nodoc
class __$$WriteFailureConfictImplCopyWithImpl<T, $Res>
    extends _$WriteFailureCopyWithImpl<T, $Res, _$WriteFailureConfictImpl<T>>
    implements _$$WriteFailureConfictImplCopyWith<T, $Res> {
  __$$WriteFailureConfictImplCopyWithImpl(_$WriteFailureConfictImpl<T> _value,
      $Res Function(_$WriteFailureConfictImpl<T>) _then)
      : super(_value, _then);
}

/// @nodoc

class _$WriteFailureConfictImpl<T> implements _WriteFailureConfict<T> {
  const _$WriteFailureConfictImpl();

  @override
  String toString() {
    return 'WriteFailure<$T>.conflict()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$WriteFailureConfictImpl<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() conflict,
    required TResult Function(String message) error,
    required TResult Function(String id) notFound,
  }) {
    return conflict();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? conflict,
    TResult? Function(String message)? error,
    TResult? Function(String id)? notFound,
  }) {
    return conflict?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? conflict,
    TResult Function(String message)? error,
    TResult Function(String id)? notFound,
    required TResult orElse(),
  }) {
    if (conflict != null) {
      return conflict();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_WriteFailureConfict<T> value) conflict,
    required TResult Function(_WriteFailureError<T> value) error,
    required TResult Function(_WriteFailureItemNotFound<T> value) notFound,
  }) {
    return conflict(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_WriteFailureConfict<T> value)? conflict,
    TResult? Function(_WriteFailureError<T> value)? error,
    TResult? Function(_WriteFailureItemNotFound<T> value)? notFound,
  }) {
    return conflict?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_WriteFailureConfict<T> value)? conflict,
    TResult Function(_WriteFailureError<T> value)? error,
    TResult Function(_WriteFailureItemNotFound<T> value)? notFound,
    required TResult orElse(),
  }) {
    if (conflict != null) {
      return conflict(this);
    }
    return orElse();
  }
}

abstract class _WriteFailureConfict<T> implements WriteFailure<T> {
  const factory _WriteFailureConfict() = _$WriteFailureConfictImpl<T>;
}

/// @nodoc
abstract class _$$WriteFailureErrorImplCopyWith<T, $Res> {
  factory _$$WriteFailureErrorImplCopyWith(_$WriteFailureErrorImpl<T> value,
          $Res Function(_$WriteFailureErrorImpl<T>) then) =
      __$$WriteFailureErrorImplCopyWithImpl<T, $Res>;
  @useResult
  $Res call({String message});
}

/// @nodoc
class __$$WriteFailureErrorImplCopyWithImpl<T, $Res>
    extends _$WriteFailureCopyWithImpl<T, $Res, _$WriteFailureErrorImpl<T>>
    implements _$$WriteFailureErrorImplCopyWith<T, $Res> {
  __$$WriteFailureErrorImplCopyWithImpl(_$WriteFailureErrorImpl<T> _value,
      $Res Function(_$WriteFailureErrorImpl<T>) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
  }) {
    return _then(_$WriteFailureErrorImpl<T>(
      null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$WriteFailureErrorImpl<T> implements _WriteFailureError<T> {
  const _$WriteFailureErrorImpl(this.message);

  @override
  final String message;

  @override
  String toString() {
    return 'WriteFailure<$T>.error(message: $message)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$WriteFailureErrorImpl<T> &&
            (identical(other.message, message) || other.message == message));
  }

  @override
  int get hashCode => Object.hash(runtimeType, message);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$WriteFailureErrorImplCopyWith<T, _$WriteFailureErrorImpl<T>>
      get copyWith =>
          __$$WriteFailureErrorImplCopyWithImpl<T, _$WriteFailureErrorImpl<T>>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() conflict,
    required TResult Function(String message) error,
    required TResult Function(String id) notFound,
  }) {
    return error(message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? conflict,
    TResult? Function(String message)? error,
    TResult? Function(String id)? notFound,
  }) {
    return error?.call(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? conflict,
    TResult Function(String message)? error,
    TResult Function(String id)? notFound,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_WriteFailureConfict<T> value) conflict,
    required TResult Function(_WriteFailureError<T> value) error,
    required TResult Function(_WriteFailureItemNotFound<T> value) notFound,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_WriteFailureConfict<T> value)? conflict,
    TResult? Function(_WriteFailureError<T> value)? error,
    TResult? Function(_WriteFailureItemNotFound<T> value)? notFound,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_WriteFailureConfict<T> value)? conflict,
    TResult Function(_WriteFailureError<T> value)? error,
    TResult Function(_WriteFailureItemNotFound<T> value)? notFound,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class _WriteFailureError<T> implements WriteFailure<T> {
  const factory _WriteFailureError(final String message) =
      _$WriteFailureErrorImpl<T>;

  String get message;
  @JsonKey(ignore: true)
  _$$WriteFailureErrorImplCopyWith<T, _$WriteFailureErrorImpl<T>>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$WriteFailureItemNotFoundImplCopyWith<T, $Res> {
  factory _$$WriteFailureItemNotFoundImplCopyWith(
          _$WriteFailureItemNotFoundImpl<T> value,
          $Res Function(_$WriteFailureItemNotFoundImpl<T>) then) =
      __$$WriteFailureItemNotFoundImplCopyWithImpl<T, $Res>;
  @useResult
  $Res call({String id});
}

/// @nodoc
class __$$WriteFailureItemNotFoundImplCopyWithImpl<T, $Res>
    extends _$WriteFailureCopyWithImpl<T, $Res,
        _$WriteFailureItemNotFoundImpl<T>>
    implements _$$WriteFailureItemNotFoundImplCopyWith<T, $Res> {
  __$$WriteFailureItemNotFoundImplCopyWithImpl(
      _$WriteFailureItemNotFoundImpl<T> _value,
      $Res Function(_$WriteFailureItemNotFoundImpl<T>) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
  }) {
    return _then(_$WriteFailureItemNotFoundImpl<T>(
      null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$WriteFailureItemNotFoundImpl<T>
    implements _WriteFailureItemNotFound<T> {
  const _$WriteFailureItemNotFoundImpl(this.id);

  @override
  final String id;

  @override
  String toString() {
    return 'WriteFailure<$T>.notFound(id: $id)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$WriteFailureItemNotFoundImpl<T> &&
            (identical(other.id, id) || other.id == id));
  }

  @override
  int get hashCode => Object.hash(runtimeType, id);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$WriteFailureItemNotFoundImplCopyWith<T, _$WriteFailureItemNotFoundImpl<T>>
      get copyWith => __$$WriteFailureItemNotFoundImplCopyWithImpl<T,
          _$WriteFailureItemNotFoundImpl<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() conflict,
    required TResult Function(String message) error,
    required TResult Function(String id) notFound,
  }) {
    return notFound(id);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? conflict,
    TResult? Function(String message)? error,
    TResult? Function(String id)? notFound,
  }) {
    return notFound?.call(id);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? conflict,
    TResult Function(String message)? error,
    TResult Function(String id)? notFound,
    required TResult orElse(),
  }) {
    if (notFound != null) {
      return notFound(id);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_WriteFailureConfict<T> value) conflict,
    required TResult Function(_WriteFailureError<T> value) error,
    required TResult Function(_WriteFailureItemNotFound<T> value) notFound,
  }) {
    return notFound(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_WriteFailureConfict<T> value)? conflict,
    TResult? Function(_WriteFailureError<T> value)? error,
    TResult? Function(_WriteFailureItemNotFound<T> value)? notFound,
  }) {
    return notFound?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_WriteFailureConfict<T> value)? conflict,
    TResult Function(_WriteFailureError<T> value)? error,
    TResult Function(_WriteFailureItemNotFound<T> value)? notFound,
    required TResult orElse(),
  }) {
    if (notFound != null) {
      return notFound(this);
    }
    return orElse();
  }
}

abstract class _WriteFailureItemNotFound<T> implements WriteFailure<T> {
  const factory _WriteFailureItemNotFound(final String id) =
      _$WriteFailureItemNotFoundImpl<T>;

  String get id;
  @JsonKey(ignore: true)
  _$$WriteFailureItemNotFoundImplCopyWith<T, _$WriteFailureItemNotFoundImpl<T>>
      get copyWith => throw _privateConstructorUsedError;
}
